import cv2
import numpy as np
from sklearn.cluster import DBSCAN

def find_nearest_edge_point(occupancy_grid, robot_position, safety_distance):
    # 将占据栅格地图转换为二值图像
    binary_map = np.where(occupancy_grid == 1, 255, 0).astype(np.uint8)  # 障碍物值为1

    # 检测边缘
    edges = cv2.Canny(binary_map, 50, 150)

    # 提取边缘点的坐标
    edge_points = np.column_stack(np.where(edges > 0))

    # 如果没有检测到任何边缘点
    if edge_points.size == 0:
        raise ValueError("No edge points detected in the map.")

    # 使用DBSCAN对边缘点聚类
    clustering = DBSCAN(eps=5, min_samples=10).fit(edge_points)
    labels = clustering.labels_

    # 选择聚类中心作为候选边缘点
    candidate_points = []
    unique_labels = set(labels)
    for label in unique_labels:
        if label == -1:
            continue  # 忽略噪声点
        cluster_points = edge_points[labels == label]
        cluster_center = np.mean(cluster_points, axis=0).astype(int)
        candidate_points.append(cluster_center)

    # 如果没有候选边缘点
    if len(candidate_points) == 0:
        raise ValueError("No candidate edge points found after clustering.")

    # 找到距离小车最近的候选边缘点，并确保满足安全距离
    robot_position = np.array(robot_position)
    candidate_points = np.array(candidate_points)
    valid_points = []

    for point in candidate_points:
        distances_to_obstacles = np.linalg.norm(edge_points - point, axis=1)
        if np.all(distances_to_obstacles >= safety_distance):
            valid_points.append(point)

    # 如果没有满足安全距离的点
    if not valid_points:
        raise ValueError("No valid edge point found within safety constraints.")

    valid_points = np.array(valid_points)
    distances = np.linalg.norm(valid_points - robot_position, axis=1)
    nearest_point_index = np.argmin(distances)
    nearest_point = valid_points[nearest_point_index]

    return nearest_point

# 示例使用
# occupancy_grid: 2D numpy 数组，值范围[0, 1]，0为自由，1为占据，0.5为未知
# robot_position: 小车位置 (y, x)
occupancy_grid = np.random.choice([0, 0.5, 1], size=(100, 100), p=[0.7, 0.2, 0.1])  # 示例地图
robot_position = (50, 50)  # 小车位置
safety_distance = 1  # 安全距离

try:
    nearest_point = find_nearest_edge_point(occupancy_grid, robot_position, safety_distance)
    print("Nearest edge point:", nearest_point) #输出的是(x,y)形式的坐标
except ValueError as e:
    print("Error:", e)
